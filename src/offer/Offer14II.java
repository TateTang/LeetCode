package offer;

/**
 * @Author tangmf
 * @Date 2021/10/11 10:18 上午
 * @Description 剑指 Offer 14- I. 剪绳子
 * 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），
 * 每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？
 * 例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
 * 示例 1：
 * 输入: 2
 * 输出: 1
 * 解释: 2 = 1 + 1, 1 × 1 = 1
 * 示例 2:
 * 输入: 10
 * 输出: 36
 * 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
 */
public class Offer14II {
    public static void main(String[] args) {
        int n = 120;
        System.out.println(new Offer14II().cuttingRope(n));
    }

    public int cuttingRope(int n) {
        /*
        贪心：每次拆成n个3，如果剩下是4，则保留4，然后相乘
          数学规律：贪心，尽量切长度为3的
          - 推论一：绳子以相等长度分为多段，得到的乘积最大
          - 推论二：尽可能将绳子以长度3等分为多段时，乘积最大
            计算结果太大，需要取模。但上一题的算法需要枚举多个值选最大的，而取模之后的大小不能反映真实大小，以至于得不到正确答案
            上一题算法的时间复杂度为本题的数据范围是1000以内，暂且不会超时，如果数据范围再扩大十倍，肯定会超时
          所谓循环取余就是每乘一次3就取次余数，为什么这种方法不会像动态规划那样影响最终结果呢，
          因为本题的动态规划涉及到数的比较，会出现取余后的数和取余前的数相比较的情况，自然会影响后面的结果，
          而贪心算法的求解过程就是简单的乘法，
          (100000009 % 1000000007) * 3 和 (100000009 * 3）% 1000000007的结果是一样的
         */
        //if (n < 3) return 1;
        //if (n == 3) return 2; //合并成n<4 返回n-1
        if (n < 4) {
            return n - 1;
        }
        long res = 1;
        int mod = 1000000007;
        //当大于4的时候，先分出一段长度为3的，直到长度小于等于4，则不再切分
        while (n > 4) {
            res = res * 3 % mod;
            n = n - 3;
        }
        return (int) (n * res % mod);
    }
}
