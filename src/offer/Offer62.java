package offer;

import java.util.ArrayList;
import java.util.List;

/**
 * @Author tangmf
 * @Date 2021/9/14 9:54 上午
 * @Description 剑指 Offer 62. 圆圈中最后剩下的数字
 * 0, 1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。
 * 求出这个圆圈里剩下的最后一个数字。
 * 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，
 * 则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
 * 示例 1：
 * 输入: n = 5, m = 3
 * 输出: 3
 * 示例 2：
 * 输入: n = 10, m = 17
 * 输出: 2
 * 约瑟夫环问题
 */
public class Offer62 {
    public static void main(String[] args) {
        int n = 5, m = 3;
        System.out.println(new Offer62().lastRemaining(n, m));
    }

    public int lastRemaining(int n, int m) {
        /*
        数学问题
        - 依次推测
          - 第一轮 [0,1,2,3,4],0开始，[0,1,2,3,4]的多轮复制，2删除
          - 第二轮[0,1,3,4]，3开始，[3,4,0,1]的多轮复制，第三个数字，0删除
          - 第三轮[1,3,4]，1开始，[1,3,4]的多轮复制，第三个数字，4删除
          - 第四轮[1,3]，1开始，[1,3]的多轮复制，第三个数字，1删除
          - 最后剩下了数字3
        新一轮的开头，每次固定的向前移动 m 个位置
        最后剩下的 3 倒着看，可以反向推出这个数字在之前每个轮次的位置
        最后剩下的3的下标是0
        - 反推
         - 第四轮反推，补上m个位置，然后模上数组大小，3下标0，位置就是 (0+3) % 2 =1
         - 第三轮反推，补上m个位置，然后模上数组大小，上一轮下标1，位置就是 (1+3) % 3 =1
         - 第二轮反推，补上m个位置，然后模上数组大小，上一轮下标1，位置就是 (1+3) % 4 =0
         - 第一轮反推，补上m个位置，然后模上数组大小，上一轮下标0，位置就是 (0+3) % 5 =3
        （当前index+m）%剩余个数


        总结：就是递归反向推理，找出元素个数为n开始的时候，存活元素的下标即可。下标就是最终答案，直接返回即可
        ð：最后只剩下一个元素，假设这个最后存活的元素为 num, 这个元素最终的的下标一定是0 （因为最后只剩这一个元素），
        所以如果我们可以推出上一轮次中这个num的下标，然后根据上一轮num的下标推断出上上一轮num的下标，
        直到推断出元素个数为n的那一轮num的下标，那我们就可以根据这个下标获取到最终的元素了。推断过程如下：
        首先最后一轮中num的下标一定是0， 这个是已知的。
        那上一轮应该是有两个元素，此轮次中 num 的下标为 (0 + m)%n = (0+3)%2 = 1; 说明这一轮删除之前num的下标为1；
        再上一轮应该有3个元素，此轮次中 num 的下标为 (1+3)%3 = 1；说明这一轮某元素被删除之前num的下标为1；
        再上一轮应该有4个元素，此轮次中 num 的下标为 (1+3)%4 = 0；说明这一轮某元素被删除之前num的下标为0；
        再上一轮应该有5个元素，此轮次中 num 的下标为 (0+3)%5 = 3；说明这一轮某元素被删除之前num的下标为3；
        ....
        因为我们要删除的序列为0-n-1, 所以求得下标其实就是求得了最终的结果。比如当n 为5的时候，num的初始下标为3，
        所以num就是3，也就是说从0-n-1的序列中， 经过n-1轮的淘汰，3这个元素最终存活下来了，也是最终的结果。
        总结一下推导公式：(此轮过后的num下标 + m) % 上轮元素个数 = 上轮num的下标
         */
        int res = 0;
        // 最后一轮剩下2个人，所以从2开始反推
        for (int i = 2; i <= n; i++) {
            res = (res + m) % i; //(此轮过后的num下标 + m) % 上轮元素个数 = 上轮num的下标
        }
        return res;
    }

    public int lastRemaining2(int n, int m) {
        /*
         * ArrayList解决，
         * - 删除的位置idx
         * - 下一个删除的位置idx+m
         * - 删除了之后需要前移动 idx+m-1
         * - 到了末尾需要重新开始 (idx+m-1)%n
         */
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            list.add(i);
        }
        int idx = 0;
        while (n > 1) {
            idx = (idx + m - 1) % n;//不断删除
            list.remove(idx);
            n--;
        }
        return list.get(0);
    }

    public int delete(List<Integer> list, int m) {
        if (list.size() > 1) {
            return delete(list, m);
        } else {
            return list.get(m);
        }
    }
}
